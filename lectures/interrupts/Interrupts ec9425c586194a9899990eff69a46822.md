# Interrupts

### Про прерывания в общих чертах.

В нашей операционной системе есть механизм (Traps), которые обслуживает следующие три вещи:

1) Hardware interrupts (Аппаратные прерывания).

2) Exception (Исключительные ситуации).

3) Software interrupts (Программные прерывания).

Чего мы в принципе хотим добиться, используя этот механизм? Представим следующую ситуацию:

```nasm
mov ...
nop <---- eip
add ...

key_pressed:
	in $KEYBOARD_PORT, %al // кладём в какой-то буффер.
	iret // чо пон мниная единица * ret?? (выясним позже, что это такое)
```

Наша программа исполняет какие-то инструкции и тут в этом время пользователь жмёт кнопку на клавиатуре. Мы договорились заранее с процессором, что есть какой-то магический адрес key_pressed, на который во время прерывания должен перейти регистр eip, выполнить пару инструкций (положить нажатую кнопку в какой-то буффер, например) и прыгнуть обратно - исполнять код.

### Как происходит механизм аппаратных (асинхронных) прерываний схематически?

Примерно так:

1) Во-первых, процессор должен откуда-то узнать, что пользователь нажал на клавиатуру.

2) Во-вторых, узнав об этом,  он должен где-то посмотреть - есть ли обработчик для данного события.

3) В-третьих, выяснив, что обработчик есть - он должен это как-то обработать, сохранив текущее состояние процессора (включая все регистры).

4) После обработки прерывания мы возвращаемся в наш код с помощью iret - инструкции, которая извлекает из стека три верхних значения и помещает их в регистры IP, CS и флагов. 

У процессора есть свой флаг в регистре флагов - IF (interrupt flag), который недоступен к модификации из пользовательских программ (не из пользовательских возможно с помощью cli и sti) .

Если IF возведен, то после каждой инструкции у процессора происходит проверка на наличие прерываний - если они есть, то происходит как раз тот самый механизм, который мы до этого обсуждали. 

Если же IF не возведён, то процессор просто не реагирует на маскируемые аппаратные прерывания и откладывает эту реакцию до более удобного момента.

### Про остальное

Программные прерывания и исключения обрабатываются тем же самым механизмом ловушек. 

Вызвать программное прерывание можно с помощью ассемблерной инструкции int.

### Interrupt Controller (Контроллер прерываний)

Нам не хотелось бы обрабатывать приоритеты и очереди прерываний в самом процессоре, тем самым загружая его данной работой. Все эти обработки выносят в отдельную микросхему, которая называется interrupt controller. Мы будем пользоваться стандартом PIC (*Programmable Interrupt Controller*), который рассчитывает на то, что с ним работает один процессор. В современном компьютере все же устроено немного сложнее - там у каждого ядра процессора есть свой LAPIC (Local Advanded PIC), а глобально во всей системе есть IO APIC (Input Output APIC), который распределяет прерывания между ядрами.

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled.png)

Назревает сразу же вопрос - “Как же PIC узнает про то, что центральный процессор обработал прерывание и можно сбрасывать сигнал об этом прерывании и браться за следующее?”

Так вот, CPU взаимодействует с PIC с помощью Port Mapped IO — так и узнает.

### Как устроены прерывания в Yabloko

Мы не хотим пуллить клавиатуру и постоянно спрашивать о том, не перенажал ли пользователь какую-то кнопку и хотим ловить прерывание, которое присылает клавиатура, обрабатывать его и выводить символ, который к нам приехал. Что нам для этого понадобится? Для этого нам нужна таблица обработчиков прерываний. Для каждого приходящего нам прерывания у нас есть структура idt_gate_t. Для каждого номера прерывания в таблице обработчиков (про природу этих номеров чуть дальше) хранится структура, которая соответствующим образом выстраивает работу с памятью. Посмотрим как выглядит таблица:

```c
enum {
    IDT_HANDLERS = 256,
};

idt_gate_t idt[IDT_HANDLERS];
```

То есть сами прерывания приходят в виде номера int X → handler, где handler - это структура idt_gate_t idt[X] в нашей таблице. В целом, обработчик это код, который лежит по адресу памяти. Теперь посмотрим на структуру idt_gate_t:

```c
typedef struct {
    uint16_t low_offset;
    uint16_t selector; // это поле содержит в себе номер сегмента, который 
// будет загружен в cs. Менять значение cs может потребоваться, когда мы 
// в пользовательском коде (режим с пониженными привилегиями) ловим прерывания,
// но обрабатываем их уже в ядре (режим с повышенными привилегиями).
    uint8_t always0;
    uint8_t type: 4; // : 4 - означает, что поле type занимает только 4 бита
// вместо 8
    uint8_t s: 1;
    uint8_t dpl: 2;
    uint8_t p: 1;
    uint16_t high_offset;
} __attribute__((packed)) idt_gate_t;
```

Мы работаем в 32-битном режиме и соответственно адрес у нас также 32-битный, поэтому мы режем наш адрес на две части: low_offset (раньше было так, что она была 16-битная и была только эта часть) и high_offset (то, что добавили потом).

Теперь погорим про природу номеров прерываний, они же индексы в таблице прерываний. По-другому они называются векторами прерываний. Первые 32 вектора зарезервировал Intel, они же оставляют за собой право их доопределить до 32 (то есть до 31 номера) в следующих процессорах. Рассмотрим первые 19 из них, которые определены:

```c
const char * const exception_messages[] = {
    [0] = "Division By Zero",
    [1] = "Debug",
    [2] = "Non Maskable Interrupt",
    [3] = "Breakpoint",
    [4] = "Into Detected Overflow",
    [5] = "Out of Bounds",
    [6] = "Invalid Opcode", // на тот случай, когда процессор прочитал инстру-
// -кцию, а декодировать её не может (возможно какой-то мусор попался)
    [7] = "No Coprocessor",

    [8] = "Double Fault", // случай когда, произошла исключительная ситуация с
// номером от 0 до 7, но для неё не нашлось обработчика. Если обработчик не
// сработал и для Double Fault, то возникает уже Triple Fault и процессор
// перезагружается.
    [9] = "Coprocessor Segment Overrun",
    [10] = "Bad TSS",
    [11] = "Segment Not Present",
    [12] = "Stack Fault",
    [13] = "General Protection Fault", // случай, когда не хватает прав для рабо-
// -ты с памятью, например, записываем что-то в read-only памяти. Эта же ситуация 
// может возникнуть при программировании ядра, когда мы не написали
// что-то для сегментов.
    [14] = "Page Fault",
    [15] = "Unknown Interrupt",

    [16] = "Coprocessor Fault",
    [17] = "Alignment Check",
    [18] = "Machine Check",
};
```

Например, если процессор ловит исключительную ситуацию - “деление на 0”, он всегда возбуждает вектор прерывания с номером 0.

Дальше нам хотелось бы иметь векторы, которые работают с прерываниями у разных устройств компьютера. Схема этого процесса выглядит таким образом:

```c
Device ->> PIC ->> CPU
```

Если что-то случилось с устройством компьютера, оно сигнализирует PIC об этом, PIC хранит информацию о том, что на устройстве было конкретное прерывание с конкретным номером и пока процессор не обработает его, PIC будет напоминать об этом CPU. Например, клавиатура, присоединенная на первой ноге к PIC, присылает IRQ1 (interrupt request - запрос на прерывание) на PIC, дальше PIC делает смещение относительно 0x20 для IRQ и уже на процессор приходит то, что вызван 33-й по счету вектор.

Как обрабатывает прерывания сам процессор? Посмотрим на код:

```nasm
/*
* mov ... // IF = 1
* ------ // interrupt handling started
* push eflags
* push error_code
* push eip
* push cs
* cli
* ljmp handler_segment:handler_offset // cs, eip = handler_segment, handler_offset
*/
```

Пусть выполняется инструкция mov по результатам которой был выставлен флаг IF (Interrupt flag), то есть процессор будет готов к обработке прерываний. Дальше процессор проверяет не сигналит ли PIC о наличии прерывания и если он действительно сигналит, то он начинает обрабатывать это прерывание. Процессор сразу же начинает в текущем стеке обработку прерывания, то есть сразу после исполнения mov. Процессор кладет значение флагов, error_code (код ошибки - доп. информация о ней), instruction pointer’а, cs и подключает прерывание инструкцией cli, далее смотрит в таблицу с битами прерываний, добывает оттуда новое значение cs и eip, загружает их. Потом мы переходим на сегмент и адрес прерывания, который лежит в таблице обработчиков. Остальные регистры в процессе мы не трогали и чтобы их не испортить нам придется их самим сохранить и восстановить, когда мы закончим обрабатывать прерывание. Есть проблема: ни в какой момент никуда не сохраняется номер вектора прерывания. Единственное, что от него зависит это пушить или нет код ошибки (error_code) и на какой хэндлер (handler_segment:handler_offset) переходить. Другой информации о том, какой вектор прерывания мы обрабатываем у нас нет.

### Обработчики.

Рассмотрим ассемблерный файл cpu/vector.S, здесь мы с помощью макро языка создаем 256 обработчиков исключений, которые мы будем называть vector\i (можете дизассамблировать файл с помощью objdump и увидите 256 функций). Эти вектора кладутся в default_handlers.

Рассмотрим сами вектора. На 31-ой строчке мы можем увидеть if — он кладет 0 в стек для тех векторов, в которых не был положен процессором код ошибки (это нужно для того, чтобы у всех обработчиков стек выглядел однородно). Потом уже мы делаем push номера обработчика.

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%201.png)

Далее мы прыгаем в функцию alltraps, которая является общим обработчиком прерываний и лежит в том же файле. 

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%202.png)

С 5-ой по 8-ую строчку мы сохраняем все сегментные регистры (регистр cs за нас уже сохранил процессор), а инструкцией pushal мы сохраняем все регистры общего назначения (чтобы потом их всех восстановить). Далее мы вызываем уже Си-шную функцию trap, определённую в cpu/idt.c.

trap — это функция, которая принимает на вход указатель на структуру registers_t, которая уже в свою очередь определена в cpu/isr.h и выглядит следующим образом. 

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%203.png)

Нетрудно догадаться, что она просто хранит в себе всю информацию о сохраненных в alltraps регистров. 

И чтобы передать указатель на registers_t мы кладём в 15-ой строчке функции alltraps регистр esp, который как раз указывает на начало нашей структуры

.

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%204.png)

Как видим — функция trap не слишком гостеприимна и сразу же нас встречает двумя if-ами с 89-ой по 94-ую строки. Объяснения такие: чтобы контролер прерываний передал следующее прерывание процессору — нужно ему сообщить, что предыдущее мы уже завершили. Поэтому мы должны сказать, что произошла ситуация EOF - end of interrupt, но поскольку контроллеров прерываний у нас два, то с 32-ого вектора по 40-ой мы сообщаем одному контроллеру, а с 40-ого уже двум. 

Далее мы уже в 97-ой строчке проверяем, что существует обработчик прерываний для нашего прерывания, и если он есть, то просто запускаем его.

Если прерывание имеет номер до 32 (зарезервированные интелом номера), то мы просто вызываем функцию panic (заставляем ядро паниковать), предварительно напечатав сообщение об ошибке, которое мы взяли с соответствующей таблицы.

### Пора возвращаться домой.

После обработки исключения мы вернёмся обратно в функцию alltraps.

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%205.png)

с 17-ой по 25-ую строчку мы восстановим все регистры, которые мы положили в стек (popal - противоположность pushal) а в 26-ой строчке убираем код ошибки и номер вектора со стека.
Далее вызываем iret, который восстанавливает cs, eip и eflags, тем самым мы возвращаемся в ту точку программы, на которой мы были прерваны для обработки прерывания.

### Разбор обработчика прерываний для клавиатуры.

Находится данный обработчик в файле driver/keyboard.c, загружаем мы его в таблицу обработчиков с помощью функции init_keyboard(), в которой вызывается register_interrupt_handler.

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%206.png)

В 18-ой строчке из порта клавиатуры мы читаем scancode — номер клавиши и в верхних старших битах сообщение о состоянии нажатия клавиши.

Таблица сканкодов имеется в том же файлике:

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%207.png)

А дальше просто очевидно обрабатываем scancode с таблицы и печатаем его на экран (25-ая строчка).

### Как хендлеры попадают в таблицу обработчиков процессора?

Это происходит благодаря функции load_idt (из cpu/idt), которая вызывается в _start (kernel.c). 

![Untitled](Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%208.png)

Функция init_idt просто заполняет нашу таблицу — она берёт адрес вектора из default_handlers и кладёт в таблицу **idt_gate_t idt[IDT_HANDLERS]**. Далее в специальную структуру мы кладём адрес нашей таблицы и с помощью ассемблерной инструкции lidt мы загружаем нашу таблицу обработчиков в процессор.