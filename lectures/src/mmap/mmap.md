# Страничная виртуальная память

Механизм _виртуальной памяти_: программа оперирует _виртуальными_
адресами оперативной памяти, отображением которых на _физическую_
память управляет операционная система.

Мы уже видели механизм сегментной виртуальной памяти, когда
виртуальный адрес является смещением относительно базы сегмента:
`phys_addr = virt_addr + segment_base`. Этот механизм устарел
и больше не применяется в современных процессорах.

Ему на смену пришёл механизм _страничной_ виртуальной памяти:
виртуальное и физическое адресные пространства делятся
на блоки определённого размера —
_страницы_, и каждая из виртуальных страниц может быть отображена на
произвольную физическую (или никуда не отображена).

[См. картинку в статье про виртуальную память](https://en.wikipedia.org/wiki/Virtual_memory)

## Механизм страничной памяти на x86_32

less maps - что ядро думает про память программы
![less maps](./img1.png)
* 1я колонка - диапазоны адресов виртуальной памяти (которыми пользуется программа)
* последняя колонка - из какой файла мы взяли этот кусок памяти
* буквы во второй колонке похожи на биты доступов на файлах (r, w, x значит, что его можно читать, записывать и исполнять.) 
* Например, r--p значит, что можно только читать; rw-p - можно читать и записывать, но не исполнять.
* третий столбец - смещение в файле (начиная с этого адреса лежит начало исполняемого файла)
* /usr/lib/x86_64-linux-gnu/libc.so.6 - стандартная библиотека языка C



Современные операционные системы используют страничную виртуальную память
(у процессора есть механизм, которые позволяет блоки памяти определенного размера (у нас это 4 Кб (0x1000), т.е. блоки
которые начинаются с кратным этому адресов) отображать в физической оперативной памяти с определенными
битами защиты.
(про каждую страницу можем отмечать, будет ли она доступна для чтения, записи и исполнения))

Можно предположить, что операционная система, запуская бинарник и создавая ему виртуальную память, все отображенные
страницы складывает в таблицу страниц и отдает процессору.

Но на самом деле операционная система в своих внутренних структурах данных, относящихся к этому процессу, записывает,
что есть диапазон памяти с нужными битами доступа, который отображен на какой-то файл на диске, начиная с какого-то
смещения.
А в таблицу страниц ничего не кладет.

Когда программа пытается обратиться к не отображенной памяти, процессор генерирует исключение PageFold.
В этот момент, когда программе понадобилась какая-то из страниц памяти, которую ей пообещала операционная система,
процессор генерирует Page fault, и процессор его обрабатывает.
    
То есть пока память не потрогал, операционная система не будет с ней ничего делать.
Когда потрогал, операционная система выделяет эту страницу памяти, отдает ее тебе, обработав исключение, добавляет
отображение в таблицу страниц и программа исполняется дальше.

Память изначально заполнена нулями. Если потрогаем страницу памяти, которая находится внутри кучи, то она найдет для нее
физическую память, занулит ее и добавит ее в таблицу страниц. 

Но malloc не зануляет память.

A calloc не записывает нули, потому что свежая память, которую он получает, и так зануленная (это если calloc берёт новую память у ОС (с помощью mmap), а если выдаёт старую память, которую кто-то раньше освободил, то, конечно, сам и записывает туда нули).

mmap - системный вызов, обращение к операционной системе, что начиная со смещения offset отобразить файл fd по адресу
памяти addr, отображение длины lenght и есть флаги flags.

![mmap](./img2.png)

* MAP_SHARED - то, что мы пишем в отображённую на файлы память, записывается в эти самые файлы

* MAP_PRIVATE - не записывается

![prog](./img3.png)

Cмотрим на вывод ./mmap textfile.txt

![смотрим на вывод /.mmap textfile.txt](./img4.png)

Отображение textfile.txt получилось размера 1 страницы (4 Кб в нашем случае), и меньше отображение быть не может.

Всегда получается целое количество страниц.

То есть размер отображения всегда кратен размеру страницы.
offset тоже должен быть кратен размеру страницы.

В режиме MAP_SHARED мы не знаем, когда у нас записываются изменения.

Чтобы синхронизировать, можно сделать msync.

Когда отображение нам больше не нужно, с помощью munmap, который принимает адрес, можем удалить отображение.

Мы постоянно используем минимальное количество оперативной памяти для тех страниц, которые не изменяются. 

Если наша программа не выполняется, а выполняются другие, которым нужна оперативная память, то отображние секции text 
выгрузится. Если программа запустится, то мы всегда сможем выгрузить отображение обратно с диска.

Редактировать бинарник просто так не получится: будет ошибка Text File busy.

![Text File busy](./img5.png)

Бывают анонимные отображения - получаем просто участок памяти, который инициализирован нулями.

(fd = -1, указываем MAP_ANONYMOUS)

![анонимные отображения](./img6.png)
